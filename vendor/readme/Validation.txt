https://github.com/Respect/Validation - тут библиотека валидации. НЕ СКАЧИВАТЬ. Устанавливать при помощи композера в папку /localhost/application/includes/conposer - тут все библиотеки
https://github.com/Respect/Validation/blob/1.1/docs/VALIDATORS.md на этой странице присутствуют все правила валидации и их описания, которые можно использовать.
https://www.youtube.com/watch?v=GhlSXyjPR7Y по этоу ссылке видео с вариантами использования библиотеки

Например правило: Numeric

v::numeric()->validate(-12); // true
v::numeric()->validate('135.0'); // true

каждое правило - это метод. Метод, который вызывается у соответствующего класса-валидатора из библиотеки
v::numeric() - это статический метод-правило. А после этого метода в конце всегда вызывается один из трех методов, которые осуществляют (запускают) проверку: validate(), check(), assert()
в виде параметра для одного из трех методов как раз выступает переменная ( или массив, объект или еще какой то вид данных, которые и нужно провалидировать)
в итоге возвращается либо false либо true

в контроллере или модели для того чтобы использовать данную библиотеку необходимо прописать простостранство имен наверху над классом use Respect\Validation\Validator as v;
и таким образом использовать класс v. Конечно же после того как был подключен файл композера который подключает все библиотеки

ПРИМЕР (проверяем почту)
if(v::email()->validate('eragorn2013@yandex.ru'))
{
	exit('Да'); // Будет ДА
}
else
{
	exit('Нет');
}

Чтобы код получился достаточно красивый можно изменить пример выше:

$rules=v::email(); // сначала прописываем все правила. В том числе можно прописывать цепочку правил

if($rules->validate('eragorn2013@yandex.ru'))// только потом проводим валидацию
{
	exit('Да');
}
else
{
	exit('Нет');
}


$rules=v::email();
if($rules->validate('eragorm2013@yandex.ru'))
{
	exit('Да');
}
else
{
	exit('Нет');
}

в своем каркасе я реализовал именно обращение через объект, который создается в главном родительском классе model по принципам описанным в примерах ранее.
теперь к методам библиотеки в дочерних классах модели (т.к. они по задумке проверяют данные) необходимо обращаться через объект $this->valid. Т.е. больше ничего создавать
или подключать не нужно. Все происходит автоматически

метод assert() удобно использовать для генерации исключений в try/catch
если в try прописать правила и запустить валидацию этим методом и валидация не будет пройдет, то assert() выбросит исключение

$rules=v::email()->length(1,6)->notEmpty();
if($rules->validate(''))
{
	exit('Да');
}
else
{
	exit('Нет');
}
в примере выше прописала цепочка правил: это должен быть адрес элетронной почты / длина строки с адресом почты не должна превышать 6 символов но и не должна быть
менее 1 символа / данная строка не должна быть пустой

правило alnum - в качестве своего параметра принимает регулярное выражение

$rules=v::alnum('a-z0-9');
if($rules->validate('1231wdsf'))
{
	exit('Да'); //+
}
else
{
	exit('Нет');//-
}
$rules=v::alnum('a-z0-9')->noWhiteSpace();
if($rules->validate('1231wdsf'))
{
	exit('Да');
}
else
{
	exit('Нет');
}

noWhiteSpace() - правило говорящее: не должно быть пробелов

<?php
use Respect\Validation\Validator as valid;

class model_site_index extends model 
{	
	public function __construct()
	{
		parent::__construct();	
		$this->date='28-03-2018';
		$this->email='eragorn2013@yandex.ru';
	}

	public function test()
	{
		$rules=valid::attribute('date', valid::date())->attribute('email', valid::email());		
		if($rules->validate($this))
		{
			exit('Да');
		}
		else
		{
			exit('Нет');
		}
	}	
}

пример выше позволяет "красиво" проверить объект

